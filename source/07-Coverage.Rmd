%\VignetteIndexEntry{SimDesign}
%\VignetteEngine{knitr::knitr}
---
title: "SimDesign"
author: "Phil Chalmers"
date: "September 22, 2015"
output:
  html_document:
    number_sections: yes
    toc: yes
---

```{r include=FALSE}
options(digits = 3)
```

# Coverage

Coverage relates to how well a proposed confidence interval captures the population parameters. For instance, given some desired nominal error rate, say, $\alpha = .05$, does the confidence interval mean based on a t-test capture the population mean across 95% of the time across random samples? Intervals that are too narrow (i.e., less than the nominal coverage rate) are generally termed 'liberal', while those that are too wide (i.e., greater than the nominal coverage rate) are considered 'conservative'. In the example below we evaluate whether the z or t-distribution is a suitable candidate to capture the population mean across different sample sizes. 

### Define the functions

```{r include=FALSE}
set.seed(1234)
```

```{r}
library(SimDesign)
#SimDesign_functions(comments = FALSE)

# z-test confidence intervals function
z.CI <- function(dat, alpha = .05){
    xbar <- mean(dat)
    SE <- sd(dat) / sqrt(length(dat))
    z <- abs(qnorm(alpha/2))
    CI <- c(xbar - z * SE, xbar + z * SE)
    CI
}

### Define design conditions. Here we want a finer range of values for plotting
Design <- expand.grid(mu = c(0, 5, 10), 
                      sample_size = c(10, 20, 30))

#---------------------------------------------------------------------

Generate <- function(condition, fixed_objects = NULL) {
    ret <- with(condition, rnorm(sample_size, mu))
    ret
}

Analyse <- function(condition, dat, fixed_objects = NULL, parameters = NULL) {
    t_test <- t.test(dat)
    t_CI <- t_test$conf.int
    z_CI <- z.CI(dat)
    ret <- c(t_CI = ECR(t_CI, parameter = condition$mu), 
             z_CI = ECR(z_CI, parameter = condition$mu)) 
    ret
}

Summarise <- function(condition, results, fixed_objects = NULL, parameters_list = NULL) {
    ret <- colMeans(results)
    ret
}

#---------------------------------------------------------------------

### Run the simulation
results <- runSimulation(Design, replications=10000, verbose=FALSE, parallel = TRUE,
                         generate=Generate, analyse=Analyse, summarise=Summarise, edit='none')
```

```{r}
print(results)
```

From these results it's clear to see that the t-distribution gives very good coverage rates across all conditions. However, the z-distriubtion CI is too liberal in the smaller sample sizes, and gives an interval that does not contain the population mean as often as desired. Around a sample size of 30 we can see that the two distributions behave reasonably well.


## An Alternative Form

The above simulation called the `ECR()` function within `analyse`, however it is entirely possible to use this function within the `summarise` block by simply supplying matricies of confidence intervals instead.

```{r eval=FALSE}
library(SimDesign)
#SimDesign_functions(comments = FALSE)

### Define design conditions. Here we want a finer range of values for plotting
Design <- expand.grid(mu = c(0, 5, 10), 
                      sample_size = c(10, 20, 30))

#-----------------------------------------------------------------

Generate <- function(condition, fixed_objects = NULL) {
    ret <- with(condition, rnorm(sample_size, mu))
    ret
}

Analyse <- function(condition, dat, fixed_objects = NULL, parameters = NULL) {
    z.CI <- function(dat, alpha = .05){
        xbar <- mean(dat)
        SE <- sd(dat) / sqrt(length(dat))
        z <- abs(qnorm(alpha/2))
        CI <- c(xbar - z * SE, xbar + z * SE)
        CI
    }                                    
    t_test <- t.test(dat)
    t_CI <- t_test$conf.int
    z_CI <- z.CI(dat)
    ret <- c(t_CI = t_CI, z_CI = z_CI) 
    ret
}

Summarise <- function(condition, results, fixed_objects = NULL, parameters_list = NULL) {
    ret <- sapply(c(1,3), function(x, results, pop) ECR(results[,c(x, x+1L)], parameter = pop), 
        results = results, pop = condition$mu)
    names(ret) <- c('t_CI', 'z_CI')
    ret
}

#-----------------------------------------------------------------

### Run the simulation
results <- runSimulation(Design, replications=10000, verbose=FALSE, parallel = FALSE,
                         generate=Generate, analyse=Analyse, summarise=Summarise, edit='none')
```


Many secondary function in `SimDesign` have this type of flexibilty, therefore it's generally useful to refer to the documentation to help think about easier ways to summarise your results.
