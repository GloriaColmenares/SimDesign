%\VignetteIndexEntry{SimDesign}
%\VignetteEngine{knitr::knitr}
---
title: "SimDesign"
author: "Phil Chalmers"
date: "September 22, 2015"
output:
  html_document:
    number_sections: yes
    toc: yes
---

```{r include=FALSE}
options(digits = 3)
```

# Catch Errors

Error catching is an important thing to consider when creating Monte Carlo simulations. Sometimes, iterative algorithms will 'fail to converge' or crash for other reasons (e.g., sparse data). However,
`SimDesign` makes this process much easier because the internal functions are wrapped in a `try` block
already, therefore the simulation will not terminate unexpectedly. Below we demonstrate what happens when errors are thrown and caught, and how this information is tracked in the returned object.

### Define the functions

As usual, define the functions of interest. 

```{r}
library(SimDesign)
# SimDesign_functions(comments=FALSE)

Design <- data.frame(N = c(10,20,30))
```

```{r}
Generate <- function(condition, fixed_objects = NULL) {
    ret <- rnorm(condition$N)    
    ret
}

Analyse <- function(condition, dat, fixed_objects = NULL, parameters = NULL) {
    whc <- sample(c(0,1,2,3), 1, prob = c(.7, .20, .05, .05))
    if(whc == 0){
       ret <- mean(dat)
    } else if(whc == 1){
        ret <- t.test() # missing arguments
    } else if(whc == 2){
        ret <- suppressWarnings(t.test('invalid')) # invalid arguments
    } else if(whc == 3){
        # throw error manually 
        stop('Manual error thrown') 
    }
    ret
}

Summarise <- function(condition, results, fixed_objects = NULL, parameters_list = NULL) {
    ret <- c(bias = bias(results, 0))
    ret
}
```

The above simulation is just an example of how errors are tracked in `SimDesign`, as well as how to 
throw a manual error in case the data should be re-drawn (e.g., when a model converges but fails to 
do so before some number of predefined iterations). 

### Run the simulation

```{r include=FALSE}
set.seed(1)
```

```{r cache=TRUE}
result <- runSimulation(Design, replications = 100, 
                       generate=Generate, analyse=Analyse, summarise=Summarise)
```

```{r}
print(result)
```

What you'll immediately notice from this output object is that the name of the error thrown, and the function from which the error was thrown, are appended as additional columns in the output with the prefix `ERROR_MESSAGE: `. Furthermore, the frequency in which the error occurred are also included for each design condition (here the `t.test.default()` error, where no inputs were supplied, occurred more often than the manually thrown error as well as the invalid-input error). 

Finally, `SimDesign` has a safety built-in feature controlled by with `max_errors` argument to avoid
getting stuck in infinite loops. By default if more than 50 errors are consecutively returned then the simulation will be haulted and the final error 
message will be returned. This saftey feature is built-in because too many consecutive `stop()` calls generally indicates a major problem in the simulation code.

### What to do

If errors occur too often then these design conditions should either be extracted out of the simulation or further inspected to determine if they can be fixed (e.g., providing better starting values, increasing convergence criteria/number of iterations, etc). The use of the debugging features may be useful to track
down issues here as well. For example, wrap the prolbematic objects in a `try()` call and add the line `if(is(object, 'try-error')) browser()` to jump into the location/replication where the object unexpectedly witnessed an error, and attempt to disern why the error occured and how to fix it.
