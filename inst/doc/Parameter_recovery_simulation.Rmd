%\VignetteIndexEntry{simTool}
%\VignetteEngine{knitr::knitr}
---
title: "SimDesign"
author: "Phil Chalmers"
date: "September 22, 2015"
output:
  html_document:
    number_sections: yes
    toc: yes
---

# Simulation: Comparing two estimators and how effectively they recover population parameters

Description of IRT versus SEM approach to item factor analysis.

### Define the conditions

```{r}
sample_sizes <- c(100, 250, 500, 1000)
test_length <- c(10, 20, 30)
Design <- expand.grid(sample_size=sample_sizes, test_length=test_length)

# save extra verbose information in an external file, and read it in later
set.seed(1234)
aux_info <- vector('list', 3)
names(aux_info) <- test_length
for(i in 1:3)
    aux_info[[i]] <- list(a = round(rlnorm(test_length[i], .2, .3), 2), 
                          d = round(rnorm(test_length[i], 0, .5), 2))
aux_info
saveRDS(aux_info, 'parameters.rds')
```

### Define the functions

Something...

```{r}
Generate <- function(condition) {
    
    library(mirt) #for simdata() function
    nitems <- as.character(condition$test_length)
    N <- condition$sample_size
        
    #source in for convience (otherwise, these could be manually define in the source code)
    parameters <- readRDS('parameters.rds')
    a <- matrix(parameters[[nitems]]$a)
    d <- matrix(parameters[[nitems]]$d)
    
    dat <- as.data.frame(simdata(a=a, d=d, N=N, itemtype = 'dich'))
    return(dat)
}

Analyse <- function(dat, parameters, condition) {
    
    library(mirt)
    library(lavaan)
    nitems <- condition$test_length
    
    mod <- try(mirt(dat, 1L, verbose=FALSE), silent=TRUE)
    if(mod@converge != 1) stop('did not converge')
    cfs <- coef(mod, simplify = TRUE, digits = Inf)
    FIML_as <- cfs$items[,1L]
    FIML_ds <- cfs$items[,2L]
    
    lavmod <- paste0('F =~ ', paste0('NA*', colnames(dat)[1L], ' + '), 
                     paste0(colnames(dat)[-1L], collapse = ' + '),
                     '\nF ~~ 1*F')
    lmod <- try(sem(lavmod, dat, ordered = colnames(dat)))
    cfs2 <- coef(lmod) * 1.702 # scaling adjustment
    DWLS_as <- cfs2[1L:nitems]
    DWLS_ds <- -1 * cfs2[(1L:nitems) + nitems]

    return(c(FIML_as=unname(FIML_as), FIML_ds=unname(FIML_ds), 
             DWLS_as=unname(DWLS_as), DWLS_ds=unname(DWLS_ds)))
}

Summarise <- function(results, parameters_list, condition) {
    
    parameters <- readRDS('parameters.rds')
    nitems <- as.character(condition$test_length)
    pop_as <- matrix(parameters[[nitems]]$a)
    pop_ds <- matrix(parameters[[nitems]]$d)
    pop <- c(pop_as, pop_ds, pop_as, pop_ds)
    
    index <- 1:ncol(results)
    
    obt_bias <- sapply(index, function(ind, obs, pop) bias(obs[,ind], pop[ind]),
                       obs = results, pop = pop)
    obt_RMSE <- sapply(index, function(ind, obs, pop) RMSE(obs[,ind], pop[ind]),
                       obs = results, pop = pop)
    names(obt_bias) <- names(obt_RMSE) <- colnames(results)
    
    ret <- c(bias=obt_bias, RMSE=obt_RMSE)
    return(ret)
}
```

### Run the simulation

```{r cache=TRUE, eval=EVAL}
res10 <- runSimulation(subset(Design, test_length == 10), replications = 1000, verbose = FALSE, 
                       generate=Generate, analyse=Analyse, summarise=Summarise, parallel = TRUE)
res20 <- runSimulation(subset(Design, test_length == 20), replications = 1000, verbose = FALSE, 
                       generate=Generate, analyse=Analyse, summarise=Summarise, parallel = TRUE)
res30 <- runSimulation(subset(Design, test_length == 30), replications = 1000, verbose = FALSE, 
                       generate=Generate, analyse=Analyse, summarise=Summarise, parallel = TRUE)
```

```{r, include=FALSE}
system('rm parameters.rds')
```

### Analyze the results
